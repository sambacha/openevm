.. py:module:: ethereum.berlin.fork

Ethereum Specification
^^^^^^^^^^^^^^^^^^^^^^

.. contents:: Table of Contents
    :backlinks: none
    :local:

Introduction
------------

Entry point for the Ethereum specification.


.. only:: stage1

Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   ethereum.berlin.fork.BlockChain



Functions
~~~~~~~~~

.. autoapisummary::
   :nosignatures:

   ethereum.berlin.fork.apply_fork
   ethereum.berlin.fork.get_last_256_block_hashes
   ethereum.berlin.fork.state_transition
   ethereum.berlin.fork.validate_header
   ethereum.berlin.fork.generate_header_hash_for_pow
   ethereum.berlin.fork.validate_proof_of_work
   ethereum.berlin.fork.check_transaction
   ethereum.berlin.fork.make_receipt
   ethereum.berlin.fork.apply_body
   ethereum.berlin.fork.validate_ommers
   ethereum.berlin.fork.pay_rewards
   ethereum.berlin.fork.process_transaction
   ethereum.berlin.fork.validate_transaction
   ethereum.berlin.fork.calculate_intrinsic_cost
   ethereum.berlin.fork.recover_sender
   ethereum.berlin.fork.signing_hash_pre155
   ethereum.berlin.fork.signing_hash_155
   ethereum.berlin.fork.signing_hash_2930
   ethereum.berlin.fork.compute_header_hash
   ethereum.berlin.fork.check_gas_limit
   ethereum.berlin.fork.calculate_block_difficulty



Attributes
~~~~~~~~~~

.. autoapisummary::

   ethereum.berlin.fork.BLOCK_REWARD
   ethereum.berlin.fork.GAS_LIMIT_ADJUSTMENT_FACTOR
   ethereum.berlin.fork.GAS_LIMIT_MINIMUM
   ethereum.berlin.fork.MINIMUM_DIFFICULTY
   ethereum.berlin.fork.MAX_OMMER_DEPTH
   ethereum.berlin.fork.BOMB_DELAY_BLOCKS
   ethereum.berlin.fork.EMPTY_OMMER_HASH


Module Details
---------------

BLOCK_REWARD
~~~~~~~~~~~~



.. py:data:: BLOCK_REWARD
   
   

.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :lines: 63-63


GAS_LIMIT_ADJUSTMENT_FACTOR
~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. py:data:: GAS_LIMIT_ADJUSTMENT_FACTOR
   
   

.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :lines: 64-64


GAS_LIMIT_MINIMUM
~~~~~~~~~~~~~~~~~



.. py:data:: GAS_LIMIT_MINIMUM
   
   

.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :lines: 65-65


MINIMUM_DIFFICULTY
~~~~~~~~~~~~~~~~~~



.. py:data:: MINIMUM_DIFFICULTY
   
   

.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :lines: 66-66


MAX_OMMER_DEPTH
~~~~~~~~~~~~~~~



.. py:data:: MAX_OMMER_DEPTH
   
   

.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :lines: 67-67


BOMB_DELAY_BLOCKS
~~~~~~~~~~~~~~~~~



.. py:data:: BOMB_DELAY_BLOCKS
   
   

.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :lines: 68-68


EMPTY_OMMER_HASH
~~~~~~~~~~~~~~~~



.. py:data:: EMPTY_OMMER_HASH
   
   

.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :lines: 69-69


BlockChain
~~~~~~~~~~


History and current state of the block chain.


.. class:: BlockChain

   

   .. py:attribute:: blocks
         :annotation: :List[ethereum.berlin.fork_types.Block]

      

   

   .. py:attribute:: state
         :annotation: :ethereum.berlin.state.State

      

   

   .. py:attribute:: chain_id
         :annotation: :ethereum.base_types.U64

      



apply_fork
~~~~~~~~~~


.. function:: apply_fork(old: BlockChain) -> BlockChain
   :noindexentry:

   Transforms the state from the previous hard fork (`old`) into the block
   chain object for this hard fork and returns it.

   When forks need to implement an irregular state transition, this function
   is used to handle the irregularity. See the :ref:`DAO Fork <dao-fork>` for
   an example.

   :param old: Previous block chain object.

   :returns: **new** -- Upgraded block chain object for this hard fork.
   :rtype: `BlockChain`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: apply_fork

get_last_256_block_hashes
~~~~~~~~~~~~~~~~~~~~~~~~~


.. function:: get_last_256_block_hashes(chain: BlockChain) -> List[ethereum.crypto.hash.Hash32]
   :noindexentry:

   Obtain the list of hashes of the previous 256 blocks in order of
   increasing block number.

   This function will return less hashes for the first 256 blocks.

   The ``BLOCKHASH`` opcode needs to access the latest hashes on the chain,
   therefore this function retrieves them.

   :param chain: History and current state.

   :returns: **recent_block_hashes** -- Hashes of the recent 256 blocks in order of increasing block number.
   :rtype: `List[Hash32]`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: get_last_256_block_hashes

state_transition
~~~~~~~~~~~~~~~~


.. function:: state_transition(chain: BlockChain, block: ethereum.berlin.fork_types.Block) -> None
   :noindexentry:

   Attempts to apply a block to an existing block chain.

   All parts of the block's contents need to be verified before being added
   to the chain. Blocks are verified by ensuring that the contents of the
   block make logical sense with the contents of the parent block. The
   information in the block's header must also match the corresponding
   information in the block.

   To implement Ethereum, in theory clients are only required to store the
   most recent 255 blocks of the chain since as far as execution is
   concerned, only those blocks are accessed. Practically, however, clients
   should store more blocks to handle reorgs.

   :param chain: History and current state.
   :param block: Block to apply to `chain`.




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: state_transition

validate_header
~~~~~~~~~~~~~~~


.. function:: validate_header(header: ethereum.berlin.fork_types.Header, parent_header: ethereum.berlin.fork_types.Header) -> None
   :noindexentry:

   Verifies a block header.

   In order to consider a block's header valid, the logic for the
   quantities in the header should match the logic for the block itself.
   For example the header timestamp should be greater than the block's parent
   timestamp because the block was created *after* the parent block.
   Additionally, the block's number should be directly folowing the parent
   block's number since it is the next block in the sequence.

   :param header: Header to check for correctness.
   :param parent_header: Parent Header of the header to check for correctness




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: validate_header

generate_header_hash_for_pow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. function:: generate_header_hash_for_pow(header: ethereum.berlin.fork_types.Header) -> ethereum.crypto.hash.Hash32
   :noindexentry:

   Generate rlp hash of the header which is to be used for Proof-of-Work
   verification.

   In other words, the PoW artefacts `mix_digest` and `nonce` are ignored
   while calculating this hash.

   A particular PoW is valid for a single hash, that hash is computed by
   this function. The `nonce` and `mix_digest` are omitted from this hash
   because they are being changed by miners in their search for a sufficient
   proof-of-work.

   :param header: The header object for which the hash is to be generated.

   :returns: **hash** -- The PoW valid rlp hash of the passed in header.
   :rtype: `Hash32`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: generate_header_hash_for_pow

validate_proof_of_work
~~~~~~~~~~~~~~~~~~~~~~


.. function:: validate_proof_of_work(header: ethereum.berlin.fork_types.Header) -> None
   :noindexentry:

   Validates the Proof of Work constraints.

   In order to verify that a miner's proof-of-work is valid for a block, a
   ``mix-digest`` and ``result`` are calculated using the ``hashimoto_light``
   hash function. The mix digest is a hash of the header and the nonce that
   is passed through and it confirms whether or not proof-of-work was done
   on the correct block. The result is the actual hash value of the block.

   :param header: Header of interest.




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: validate_proof_of_work

check_transaction
~~~~~~~~~~~~~~~~~


.. function:: check_transaction(tx: ethereum.berlin.fork_types.Transaction, gas_available: ethereum.base_types.Uint, chain_id: ethereum.base_types.U64) -> ethereum.berlin.fork_types.Address
   :noindexentry:

   Check if the transaction is includable in the block.

   :param tx: The transaction.
   :param gas_available: The gas remaining in the block.
   :param chain_id: The ID of the current chain.

   :returns: The sender of the transaction.
   :rtype: sender_address

   :raises InvalidBlock :: If the transaction is not includable.




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: check_transaction

make_receipt
~~~~~~~~~~~~


.. function:: make_receipt(tx: ethereum.berlin.fork_types.Transaction, has_erred: bool, cumulative_gas_used: ethereum.base_types.Uint, logs: Tuple[ethereum.berlin.fork_types.Log, Ellipsis]) -> Union[ethereum.base_types.Bytes, ethereum.berlin.fork_types.Receipt]
   :noindexentry:

   Make the receipt for a transaction that was executed.

   :param tx: The executed transaction.
   :param has_erred: Whether the top level frame of the transaction exited with an error.
   :param cumulative_gas_used: The total gas used so far in the block after the transaction was
                               executed.
   :param logs: The logs produced by the transaction.

   :returns: The receipt for the transaction.
   :rtype: receipt




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: make_receipt

apply_body
~~~~~~~~~~


.. function:: apply_body(state: ethereum.berlin.state.State, block_hashes: List[ethereum.crypto.hash.Hash32], coinbase: ethereum.berlin.fork_types.Address, block_number: ethereum.base_types.Uint, block_gas_limit: ethereum.base_types.Uint, block_time: ethereum.base_types.U256, block_difficulty: ethereum.base_types.Uint, transactions: Tuple[Union[ethereum.berlin.fork_types.LegacyTransaction, ethereum.base_types.Bytes], Ellipsis], ommers: Tuple[ethereum.berlin.fork_types.Header, Ellipsis], chain_id: ethereum.base_types.U64) -> Tuple[ethereum.base_types.Uint, ethereum.berlin.fork_types.Root, ethereum.berlin.fork_types.Root, ethereum.berlin.fork_types.Bloom, ethereum.berlin.state.State]
   :noindexentry:

   Executes a block.

   Many of the contents of a block are stored in data structures called
   tries. There is a transactions trie which is similar to a ledger of the
   transactions stored in the current block. There is also a receipts trie
   which stores the results of executing a transaction, like the post state
   and gas used. This function creates and executes the block that is to be
   added to the chain.

   :param state: Current account state.
   :param block_hashes: List of hashes of the previous 256 blocks in the order of
                        increasing block number.
   :param coinbase: Address of account which receives block reward and transaction fees.
   :param block_number: Position of the block within the chain.
   :param block_gas_limit: Initial amount of gas available for execution in this block.
   :param block_time: Time the block was produced, measured in seconds since the epoch.
   :param block_difficulty: Difficulty of the block.
   :param transactions: Transactions included in the block.
   :param ommers: Headers of ancestor blocks which are not direct parents (formerly
                  uncles.)
   :param chain_id: ID of the executing chain.

   :returns: * **gas_available** (`ethereum.base_types.Uint`) -- Remaining gas after all transactions have been executed.
             * **transactions_root** (`ethereum.fork_types.Root`) -- Trie root of all the transactions in the block.
             * **receipt_root** (`ethereum.fork_types.Root`) -- Trie root of all the receipts in the block.
             * **block_logs_bloom** (`Bloom`) -- Logs bloom of all the logs included in all the transactions of the
               block.
             * **state** (`ethereum.fork_types.State`) -- State after all transactions have been executed.




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: apply_body

validate_ommers
~~~~~~~~~~~~~~~


.. function:: validate_ommers(ommers: Tuple[ethereum.berlin.fork_types.Header, Ellipsis], block_header: ethereum.berlin.fork_types.Header, chain: BlockChain) -> None
   :noindexentry:

   Validates the ommers mentioned in the block.

   An ommer block is a block that wasn't canonically added to the
   blockchain because it wasn't validated as fast as the canonical block
   but was mined at the same time.

   To be considered valid, the ommers must adhere to the rules defined in
   the Ethereum protocol. The maximum amount of ommers is 2 per block and
   there cannot be duplicate ommers in a block. Many of the other ommer
   contraints are listed in the in-line comments of this function.

   :param ommers: List of ommers mentioned in the current block.
   :param block_header: The header of current block.
   :param chain: History and current state.




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: validate_ommers

pay_rewards
~~~~~~~~~~~


.. function:: pay_rewards(state: ethereum.berlin.state.State, block_number: ethereum.base_types.Uint, coinbase: ethereum.berlin.fork_types.Address, ommers: Tuple[ethereum.berlin.fork_types.Header, Ellipsis]) -> None
   :noindexentry:

   Pay rewards to the block miner as well as the ommers miners.

   The miner of the canonical block is rewarded with the predetermined
   block reward, ``BLOCK_REWARD``, plus a variable award based off of the
   number of ommer blocks that were mined around the same time, and included
   in the canonical block's header. An ommer block is a block that wasn't
   added to the canonical blockchain because it wasn't validated as fast as
   the accepted block but was mined at the same time. Although not all blocks
   that are mined are added to the canonical chain, miners are still paid a
   reward for their efforts. This reward is called an ommer reward and is
   calculated based on the number associated with the ommer block that they
   mined.

   :param state: Current account state.
   :param block_number: Position of the block within the chain.
   :param coinbase: Address of account which receives block reward and transaction fees.
   :param ommers: List of ommers mentioned in the current block.




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: pay_rewards

process_transaction
~~~~~~~~~~~~~~~~~~~


.. function:: process_transaction(env: ethereum.berlin.vm.Environment, tx: ethereum.berlin.fork_types.Transaction) -> Tuple[ethereum.base_types.Uint, Tuple[ethereum.berlin.fork_types.Log, Ellipsis], bool]
   :noindexentry:

   Execute a transaction against the provided environment.

   This function processes the actions needed to execute a transaction.
   It decrements the sender's account after calculating the gas fee and
   refunds them the proper amount after execution. Calling contracts,
   deploying code, and incrementing nonces are all examples of actions that
   happen within this function or from a call made within this function.

   Accounts that are marked for deletion are processed and destroyed after
   execution.

   :param env: Environment for the Ethereum Virtual Machine.
   :param tx: Transaction to execute.

   :returns: * **gas_left** (`ethereum.base_types.U256`) -- Remaining gas after execution.
             * **logs** (`Tuple[ethereum.fork_types.Log, ...]`) -- Logs generated during execution.




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: process_transaction

validate_transaction
~~~~~~~~~~~~~~~~~~~~


.. function:: validate_transaction(tx: ethereum.berlin.fork_types.Transaction) -> bool
   :noindexentry:

   Verifies a transaction.

   The gas in a transaction gets used to pay for the intrinsic cost of
   operations, therefore if there is insufficient gas then it would not
   be possible to execute a transaction and it will be declared invalid.

   Additionally, the nonce of a transaction must not equal or exceed the
   limit defined in `EIP-2681 <https://eips.ethereum.org/EIPS/eip-2681>`_.
   In practice, defining the limit as ``2**64-1`` has no impact because
   sending ``2**64-1`` transactions is improbable. It's not strictly
   impossible though, ``2**64-1`` transactions is the entire capacity of the
   Ethereum blockchain at 2022 gas limits for a little over 22 years.

   :param tx: Transaction to validate.

   :returns: **verified** -- True if the transaction can be executed, or False otherwise.
   :rtype: `bool`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: validate_transaction

calculate_intrinsic_cost
~~~~~~~~~~~~~~~~~~~~~~~~


.. function:: calculate_intrinsic_cost(tx: ethereum.berlin.fork_types.Transaction) -> ethereum.base_types.Uint
   :noindexentry:

   Calculates the gas that is charged before execution is started.

   The intrinsic cost of the transaction is charged before execution has
   begun. Functions/operations in the EVM cost money to execute so this
   intrinsic cost is for the operations that need to be paid for as part of
   the transaction. Data transfer, for example, is part of this intrinsic
   cost. It costs ether to send data over the wire and that ether is
   accounted for in the intrinsic cost calculated in this function. This
   intrinsic cost must be calculated and paid for before execution in order
   for all operations to be implemented.

   :param tx: Transaction to compute the intrinsic cost of.

   :returns: **verified** -- The intrinsic cost of the transaction.
   :rtype: `ethereum.base_types.Uint`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: calculate_intrinsic_cost

recover_sender
~~~~~~~~~~~~~~


.. function:: recover_sender(chain_id: ethereum.base_types.U64, tx: ethereum.berlin.fork_types.Transaction) -> ethereum.berlin.fork_types.Address
   :noindexentry:

   Extracts the sender address from a transaction.

   The v, r, and s values are the three parts that make up the signature
   of a transaction. In order to recover the sender of a transaction the two
   components needed are the signature (``v``, ``r``, and ``s``) and the
   signing hash of the transaction. The sender's public key can be obtained
   with these two values and therefore the sender address can be retrieved.

   :param tx: Transaction of interest.
   :param chain_id: ID of the executing chain.

   :returns: **sender** -- The address of the account that signed the transaction.
   :rtype: `ethereum.fork_types.Address`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: recover_sender

signing_hash_pre155
~~~~~~~~~~~~~~~~~~~


.. function:: signing_hash_pre155(tx: ethereum.berlin.fork_types.Transaction) -> ethereum.crypto.hash.Hash32
   :noindexentry:

   Compute the hash of a transaction used in a legacy (pre EIP 155) signature.

   :param tx: Transaction of interest.

   :returns: **hash** -- Hash of the transaction.
   :rtype: `ethereum.crypto.hash.Hash32`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: signing_hash_pre155

signing_hash_155
~~~~~~~~~~~~~~~~


.. function:: signing_hash_155(tx: ethereum.berlin.fork_types.Transaction, chain_id: ethereum.base_types.U64) -> ethereum.crypto.hash.Hash32
   :noindexentry:

   Compute the hash of a transaction used in a EIP 155 signature.

   :param tx: Transaction of interest.
   :param chain_id: The id of the current chain.

   :returns: **hash** -- Hash of the transaction.
   :rtype: `ethereum.crypto.hash.Hash32`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: signing_hash_155

signing_hash_2930
~~~~~~~~~~~~~~~~~


.. function:: signing_hash_2930(tx: ethereum.berlin.fork_types.AccessListTransaction) -> ethereum.crypto.hash.Hash32
   :noindexentry:

   Compute the hash of a transaction used in a EIP 2930 signature.

   :param tx: Transaction of interest.

   :returns: **hash** -- Hash of the transaction.
   :rtype: `ethereum.crypto.hash.Hash32`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: signing_hash_2930

compute_header_hash
~~~~~~~~~~~~~~~~~~~


.. function:: compute_header_hash(header: ethereum.berlin.fork_types.Header) -> ethereum.crypto.hash.Hash32
   :noindexentry:

   Computes the hash of a block header.

   The header hash of a block is the canonical hash that is used to refer
   to a specific block and completely distinguishes a block from another.

   ``keccak256`` is a function that produces a 256 bit hash of any input.
   It also takes in any number of bytes as an input and produces a single
   hash for them. A hash is a completely unique output for a single input.
   So an input corresponds to one unique hash that can be used to identify
   the input exactly.

   Prior to using the ``keccak256`` hash function, the header must be
   encoded using the Recursive-Length Prefix. See :ref:`rlp`.
   RLP encoding the header converts it into a space-efficient format that
   allows for easy transfer of data between nodes. The purpose of RLP is to
   encode arbitrarily nested arrays of binary data, and RLP is the primary
   encoding method used to serialize objects in Ethereum's execution layer.
   The only purpose of RLP is to encode structure; encoding specific data
   types (e.g. strings, floats) is left up to higher-order protocols.

   :param header: Header of interest.

   :returns: **hash** -- Hash of the header.
   :rtype: `ethereum.crypto.hash.Hash32`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: compute_header_hash

check_gas_limit
~~~~~~~~~~~~~~~


.. function:: check_gas_limit(gas_limit: ethereum.base_types.Uint, parent_gas_limit: ethereum.base_types.Uint) -> bool
   :noindexentry:

   Validates the gas limit for a block.

   The bounds of the gas limit, ``max_adjustment_delta``, is set as the
   quotient of the parent block's gas limit and the
   ``GAS_LIMIT_ADJUSTMENT_FACTOR``. Therefore, if the gas limit that is
   passed through as a parameter is greater than or equal to the *sum* of
   the parent's gas and the adjustment delta then the limit for gas is too
   high and fails this function's check. Similarly, if the limit is less
   than or equal to the *difference* of the parent's gas and the adjustment
   delta *or* the predefined ``GAS_LIMIT_MINIMUM`` then this function's
   check fails because the gas limit doesn't allow for a sufficient or
   reasonable amount of gas to be used on a block.

   :param gas_limit: Gas limit to validate.
   :param parent_gas_limit: Gas limit of the parent block.

   :returns: **check** -- True if gas limit constraints are satisfied, False otherwise.
   :rtype: `bool`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: check_gas_limit

calculate_block_difficulty
~~~~~~~~~~~~~~~~~~~~~~~~~~


.. function:: calculate_block_difficulty(block_number: ethereum.base_types.Uint, block_timestamp: ethereum.base_types.U256, parent_timestamp: ethereum.base_types.U256, parent_difficulty: ethereum.base_types.Uint, parent_has_ommers: bool) -> ethereum.base_types.Uint
   :noindexentry:

   Computes difficulty of a block using its header and parent header.

   The difficulty is determined by the time the block was created after its
   parent. The ``offset`` is calculated using the parent block's difficulty,
   ``parent_difficulty``, and the timestamp between blocks. This offset is
   then added to the parent difficulty and is stored as the ``difficulty``
   variable. If the time between the block and its parent is too short, the
   offset will result in a positive number thus making the sum of
   ``parent_difficulty`` and ``offset`` to be a greater value in order to
   avoid mass forking. But, if the time is long enough, then the offset
   results in a negative value making the block less difficult than
   its parent.

   The base standard for a block's difficulty is the predefined value
   set for the genesis block since it has no parent. So, a block
   can't be less difficult than the genesis block, therefore each block's
   difficulty is set to the maximum value between the calculated
   difficulty and the ``GENESIS_DIFFICULTY``.

   :param block_number: Block number of the block.
   :param block_timestamp: Timestamp of the block.
   :param parent_timestamp: Timestamp of the parent block.
   :param parent_difficulty: difficulty of the parent block.
   :param parent_has_ommers: does the parent have ommers.

   :returns: **difficulty** -- Computed difficulty for a block.
   :rtype: `ethereum.base_types.Uint`




.. undocinclude:: /../src/ethereum/berlin/fork.py
   :language: python
   :pyobject: calculate_block_difficulty
