<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_namespaceevmc" xml:lang="en-US">
<title>evmc Namespace Reference</title>
<indexterm><primary>evmc</primary></indexterm>
<para>

<para>EVMC C++ API - wrappers and bindings for C++. </para>
 
</para>
<simplesect>
    <title>Namespaces    </title>
        <itemizedlist>
            <listitem><para>namespace <link linkend="_namespaceevmc_1_1fnv">fnv</link></para>
</listitem>
            <listitem><para>namespace <link linkend="_namespaceevmc_1_1literals">literals</link></para>
</listitem>
            <listitem><para>namespace <link linkend="_namespaceevmc_1_1tooling">tooling</link></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Classes    </title>
        <itemizedlist>
            <listitem><para>struct <link linkend="_structevmc_1_1account">account</link></para>
</listitem>
            <listitem><para>struct <link linkend="_structevmc_1_1address">address</link></para>

<para>The big-endian 160-bit hash suitable for keeping an Ethereum address. </para>
</listitem>
            <listitem><para>struct <link linkend="_structevmc_1_1bytes32">bytes32</link></para>

<para>The fixed size array of 32 bytes for storing 256-bit EVM values. </para>
</listitem>
            <listitem><para>struct <link linkend="_structevmc_1_1hex__error">hex_error</link></para>

<para>Hex decoding exception. </para>
</listitem>
            <listitem><para>class <link linkend="_classevmc_1_1Host">Host</link></para>

<para>Abstract class to be used by <link linkend="_classevmc_1_1Host">Host</link> implementations. </para>
</listitem>
            <listitem><para>class <link linkend="_classevmc_1_1HostContext">HostContext</link></para>

<para>Wrapper around EVMC host context / host interface. </para>
</listitem>
            <listitem><para>class <link linkend="_classevmc_1_1HostInterface">HostInterface</link></para>

<para>The EVMC <link linkend="_classevmc_1_1Host">Host</link> interface. </para>
</listitem>
            <listitem><para>struct <link linkend="_structevmc_1_1MockedAccount">MockedAccount</link></para>

<para>Mocked account. </para>
</listitem>
            <listitem><para>class <link linkend="_classevmc_1_1MockedHost">MockedHost</link></para>

<para>Mocked EVMC <link linkend="_classevmc_1_1Host">Host</link> implementation. </para>
</listitem>
            <listitem><para>class <link linkend="_classevmc_1_1result">result</link></para>

<para>The EVM code execution result. </para>
</listitem>
            <listitem><para>struct <link linkend="_structevmc_1_1storage__value">storage_value</link></para>

<para>Extended value (by dirty flag) for account storage. </para>
</listitem>
            <listitem><para>class <link linkend="_classevmc_1_1VM">VM</link></para>

<para>The <link linkend="_classevmc_1_1VM">VM</link> instance. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Typedefs    </title>
        <itemizedlist>
            <listitem><para>using <link linkend="_namespaceevmc_1a85ff0436efd1c2e8b065f73b361269e1">accounts</link> = std::map&lt; <link linkend="_structevmc_1_1address">evmc::address</link>, <link linkend="_structevmc_1_1account">account</link> &gt;</para>
</listitem>
            <listitem><para>using <link linkend="_namespaceevmc_1a92bc6b73f1ce3a2b2eea018cf902c4da">uint256be</link> = <link linkend="_structevmc_1_1bytes32">bytes32</link></para>

<para>The alias for <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> to represent a big-endian 256-bit integer. </para>
</listitem>
            <listitem><para>using <link linkend="_namespaceevmc_1a092c09f674d9cb5f0ba31d0f86537f4a">bytes</link> = std::basic_string&lt; uint8_t &gt;</para>

<para>String of uint8_t chars. </para>
</listitem>
            <listitem><para>using <link linkend="_namespaceevmc_1a539bc1335390844ee67ae697ec457720">bytes_view</link> = std::basic_string_view&lt; uint8_t &gt;</para>

<para>String view of uint8_t chars. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Enumerations    </title>
        <itemizedlist>
            <listitem><para>enum class <link linkend="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4">hex_errc</link> { <link linkend="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4a52e6eb82c226e9bfa738fa47d7e359dd">invalid_hex_digit</link> = 1
, <link linkend="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4aac6aff673f8bde724199fc07cea34f63">incomplete_hex_byte_pair</link> = 2
 }</para>

<para>Hex decoding error codes. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Functions    </title>
        <itemizedlist>
            <listitem><para>constexpr uint64_t <link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link> (const uint8_t *data) noexcept</para>

<para>Loads 64 bits / 8 bytes of data from the given <computeroutput>data</computeroutput> array in big-endian order. </para>
</listitem>
            <listitem><para>constexpr uint64_t <link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link> (const uint8_t *data) noexcept</para>

<para>Loads 64 bits / 8 bytes of data from the given <computeroutput>data</computeroutput> array in little-endian order. </para>
</listitem>
            <listitem><para>constexpr uint32_t <link linkend="_namespaceevmc_1a2170432bbbef84b33ce6dda30904068e">load32be</link> (const uint8_t *data) noexcept</para>

<para>Loads 32 bits / 4 bytes of data from the given <computeroutput>data</computeroutput> array in big-endian order. </para>
</listitem>
            <listitem><para>constexpr uint32_t <link linkend="_namespaceevmc_1ada9ae3e2b40c36dbea8b6fe8ab70375b">load32le</link> (const uint8_t *data) noexcept</para>

<para>Loads 32 bits / 4 bytes of data from the given <computeroutput>data</computeroutput> array in little-endian order. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1a3f6b3b885e1053cebe81913583212e70">operator==</link> (const <link linkend="_structevmc_1_1address">address</link> &amp;a, const <link linkend="_structevmc_1_1address">address</link> &amp;b) noexcept</para>

<para>The &quot;equal to&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1acef96efd7f9847cc089834dff73054bd">operator!=</link> (const <link linkend="_structevmc_1_1address">address</link> &amp;a, const <link linkend="_structevmc_1_1address">address</link> &amp;b) noexcept</para>

<para>The &quot;not equal to&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1a0a5557fb3dc3c04da6ef466ec3bb4d4c">operator&lt;</link> (const <link linkend="_structevmc_1_1address">address</link> &amp;a, const <link linkend="_structevmc_1_1address">address</link> &amp;b) noexcept</para>

<para>The &quot;less than&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1a44333e715985f766f2493b20ed665fbd">operator&gt;</link> (const <link linkend="_structevmc_1_1address">address</link> &amp;a, const <link linkend="_structevmc_1_1address">address</link> &amp;b) noexcept</para>

<para>The &quot;greater than&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1ac0dc436fe57925210dcd0481a79e9784">operator&lt;=</link> (const <link linkend="_structevmc_1_1address">address</link> &amp;a, const <link linkend="_structevmc_1_1address">address</link> &amp;b) noexcept</para>

<para>The &quot;less than or equal to&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1aa1739e6e990dbd1fd3d30b249b1d0d58">operator&gt;=</link> (const <link linkend="_structevmc_1_1address">address</link> &amp;a, const <link linkend="_structevmc_1_1address">address</link> &amp;b) noexcept</para>

<para>The &quot;greater than or equal to&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1a338b7c7a6dd5c12c0e37e5e8ef729100">operator==</link> (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;b) noexcept</para>

<para>The &quot;equal to&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1a5917d256b4c67912a47d3a54f849f751">operator!=</link> (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;b) noexcept</para>

<para>The &quot;not equal to&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1a4a0c61db81ebf11230c1506f7fc9e003">operator&lt;</link> (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;b) noexcept</para>

<para>The &quot;less than&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1a04835f698b6a2a5d2fbc3f8234518aed">operator&gt;</link> (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;b) noexcept</para>

<para>The &quot;greater than&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1a8580df251c76ac9b0a1561cbfda93274">operator&lt;=</link> (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;b) noexcept</para>

<para>The &quot;less than or equal to&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1ad830a8c519d4baf674a220480efc8ad3">operator&gt;=</link> (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;b) noexcept</para>

<para>The &quot;greater than or equal to&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1afc53d0e831bda94fbf31a64d224c8d24">is_zero</link> (const <link linkend="_structevmc_1_1address">address</link> &amp;a) noexcept</para>

<para>Checks if the given address is the zero address. </para>
</listitem>
            <listitem><para>constexpr bool <link linkend="_namespaceevmc_1a2277f8eca7df22f45a4476d3fe6342fe">is_zero</link> (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp;a) noexcept</para>

<para>Checks if the given <link linkend="_structevmc_1_1bytes32">bytes32</link> object has all zero bytes. </para>
</listitem>
            <listitem><para>const char * <link linkend="_namespaceevmc_1a44c9aad0ac3f324d817e18720a1e37de">to_string</link> (<link linkend="_group__EVMC_1ga4c0be97f333c050ff45321fcaa34d920">evmc_status_code</link> status_code) noexcept</para>

<para>Returns text representation of the <link linkend="_group__EVMC_1ga4c0be97f333c050ff45321fcaa34d920">evmc_status_code</link>. </para>
</listitem>
            <listitem><para>const char * <link linkend="_namespaceevmc_1a773edff68f6e013b3c809bb4c6ea33d3">to_string</link> (<link linkend="_group__EVMC_1gae5759b1590071966ccf6a505b52a0ef7">evmc_revision</link> rev) noexcept</para>

<para>Returns the name of the <link linkend="_group__EVMC_1gae5759b1590071966ccf6a505b52a0ef7">evmc_revision</link>. </para>
</listitem>
            <listitem><para>const std::error_category &amp; <link linkend="_namespaceevmc_1ab7adb84a6060aa244b75958d73752696">hex_category</link> () noexcept</para>

<para>Obtains a reference to the static error category object for hex errors. </para>
</listitem>
            <listitem><para>std::error_code <link linkend="_namespaceevmc_1aaf35d1ee5ad04f36c4287e9bafb4bd48">make_error_code</link> (<link linkend="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4">hex_errc</link> errc) noexcept</para>

<para>Creates error_code object out of a hex error code value. </para>
</listitem>
            <listitem><para>std::string <link linkend="_namespaceevmc_1a19a82782b528ebd37782eb145cf4152c">hex</link> (uint8_t b) noexcept</para>

<para>Encode a byte to a hex string. </para>
</listitem>
            <listitem><para>std::error_code <link linkend="_namespaceevmc_1aad6a175f9f53ee5700cb0c233efba79b">validate_hex</link> (std::string_view <link linkend="_namespaceevmc_1a19a82782b528ebd37782eb145cf4152c">hex</link>) noexcept</para>

<para>Validates hex encoded string. </para>
</listitem>
            <listitem><para><link linkend="_namespaceevmc_1a092c09f674d9cb5f0ba31d0f86537f4a">bytes</link> <link linkend="_namespaceevmc_1a4d4e349e08f3fed84bbd6424208a43cf">from_hex</link> (std::string_view <link linkend="_namespaceevmc_1a19a82782b528ebd37782eb145cf4152c">hex</link>)</para>

<para>Decodes hex encoded string to bytes. </para>
</listitem>
            <listitem><para>std::string <link linkend="_namespaceevmc_1adb1773c2909e66879ce13de2a49c5fee">hex</link> (<link linkend="_namespaceevmc_1a539bc1335390844ee67ae697ec457720">bytes_view</link> bs)</para>

<para>Encodes bytes as hex string. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Variables    </title>
        <itemizedlist>
            <listitem><para>constexpr auto <link linkend="_namespaceevmc_1a9843b267dc279832b0ff9578b7dacdb7">make_result</link> = <link linkend="_group__helpers_1ga1eb1facc9b5ddacda368ffdeb89d1a20">evmc_make_result</link></para>

<para>Alias for <link linkend="_group__helpers_1ga1eb1facc9b5ddacda368ffdeb89d1a20">evmc_make_result()</link>. </para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para>EVMC C++ API - wrappers and bindings for C++. </para>
</section>
<section>
<title>Typedef Documentation</title>
<anchor xml:id="_namespaceevmc_1a85ff0436efd1c2e8b065f73b361269e1"/><section>
    <title>accounts</title>
<indexterm><primary>accounts</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>accounts</secondary></indexterm>
<para><computeroutput>using <link linkend="_namespaceevmc_1a85ff0436efd1c2e8b065f73b361269e1">evmc::accounts</link> = typedef std::map&lt;<link linkend="_structevmc_1_1address">evmc::address</link>, <link linkend="_structevmc_1_1account">account</link>&gt;</computeroutput></para><para>
Definition at line <link linkend="_example__host_8cpp_source_1l00042">42</link> of file <link linkend="_example__host_8cpp_source">example_host.cpp</link>.</para>
</section>
<anchor xml:id="_namespaceevmc_1a092c09f674d9cb5f0ba31d0f86537f4a"/><section>
    <title>bytes</title>
<indexterm><primary>bytes</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>bytes</secondary></indexterm>
<para><computeroutput>typedef std::basic_string&lt; uint8_t &gt; <link linkend="_namespaceevmc_1a092c09f674d9cb5f0ba31d0f86537f4a">evmc::bytes</link></computeroutput></para><para>

<para>String of uint8_t chars. </para>
</para>

<para>The string of bytes. </para>
<para>
Definition at line <link linkend="_hex_8hpp_source_1l00015">15</link> of file <link linkend="_hex_8hpp_source">hex.hpp</link>.</para>
</section>
<anchor xml:id="_namespaceevmc_1a539bc1335390844ee67ae697ec457720"/><section>
    <title>bytes_view</title>
<indexterm><primary>bytes_view</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>bytes_view</secondary></indexterm>
<para><computeroutput>using <link linkend="_namespaceevmc_1a539bc1335390844ee67ae697ec457720">evmc::bytes_view</link> = typedef std::basic_string_view&lt;uint8_t&gt;</computeroutput></para><para>

<para>String view of uint8_t chars. </para>
</para>
<para>
Definition at line <link linkend="_hex_8hpp_source_1l00018">18</link> of file <link linkend="_hex_8hpp_source">hex.hpp</link>.</para>
</section>
<anchor xml:id="_namespaceevmc_1a92bc6b73f1ce3a2b2eea018cf902c4da"/><section>
    <title>uint256be</title>
<indexterm><primary>uint256be</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>uint256be</secondary></indexterm>
<para><computeroutput>using <link linkend="_namespaceevmc_1a92bc6b73f1ce3a2b2eea018cf902c4da">evmc::uint256be</link> = typedef <link linkend="_structevmc_1_1bytes32">bytes32</link></computeroutput></para><para>

<para>The alias for <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> to represent a big-endian 256-bit integer. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00117">117</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
</section>
</section>
<section>
<title>Enumeration Type Documentation</title>
<anchor xml:id="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4"/><section>
    <title>hex_errc</title>
<indexterm><primary>hex_errc</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>hex_errc</secondary></indexterm>
<para><computeroutput>enum class <link linkend="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4">evmc::hex_errc</link><computeroutput>[strong]</computeroutput></computeroutput></para><para>

<para>Hex decoding error codes. </para>
</para>
<informaltable frame="all">
<title>Enumerator</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<tbody>
<row><entry><indexterm><primary>invalid_hex_digit</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>invalid_hex_digit</secondary></indexterm>
<anchor xml:id="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4a52e6eb82c226e9bfa738fa47d7e359dd"/>invalid_hex_digit</entry><entry>
<para>Invalid hex digit encountered during decoding. </para>
</entry></row><row><entry><indexterm><primary>incomplete_hex_byte_pair</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>incomplete_hex_byte_pair</secondary></indexterm>
<anchor xml:id="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4aac6aff673f8bde724199fc07cea34f63"/>incomplete_hex_byte_pair</entry><entry>
<para>Input contains incomplete hex byte (length is odd). </para>
</entry></row>    </tbody>
    </tgroup>
</informaltable>
<para>
Definition at line <link linkend="_hex_8hpp_source_1l00021">21</link> of file <link linkend="_hex_8hpp_source">hex.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00022"/>00022 {
<anchor xml:id="_namespaceevmc_1l00024"/>00024 &#32;&#32;&#32;&#32;<link linkend="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4a52e6eb82c226e9bfa738fa47d7e359dd">invalid_hex_digit</link>&#32;=&#32;1,
<anchor xml:id="_namespaceevmc_1l00025"/>00025 
<anchor xml:id="_namespaceevmc_1l00027"/>00027 &#32;&#32;&#32;&#32;<link linkend="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4aac6aff673f8bde724199fc07cea34f63">incomplete_hex_byte_pair</link>&#32;=&#32;2,
<anchor xml:id="_namespaceevmc_1l00028"/>00028 };
</programlisting></section>
</section>
<section>
<title>Function Documentation</title>
<anchor xml:id="_namespaceevmc_1a4d4e349e08f3fed84bbd6424208a43cf"/><section>
    <title>from_hex()</title>
<indexterm><primary>from_hex</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>from_hex</secondary></indexterm>
<para><computeroutput><link linkend="_namespaceevmc_1a092c09f674d9cb5f0ba31d0f86537f4a">bytes</link> evmc::from_hex (std::string_view hex)</computeroutput></para><para>

<para>Decodes hex encoded string to bytes. </para>
</para>

<para>Throws <link linkend="_structevmc_1_1hex__error">hex_error</link> with the appropriate error code. </para>
</section>
<anchor xml:id="_namespaceevmc_1adb1773c2909e66879ce13de2a49c5fee"/><section>
    <title>hex()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>hex</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>hex</secondary></indexterm>
<para><computeroutput>std::string evmc::hex (<link linkend="_namespaceevmc_1a539bc1335390844ee67ae697ec457720">bytes_view</link> bs)</computeroutput></para><para>

<para>Encodes bytes as hex string. </para>
</para>
</section>
<anchor xml:id="_namespaceevmc_1a19a82782b528ebd37782eb145cf4152c"/><section>
    <title>hex()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>hex</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>hex</secondary></indexterm>
<para><computeroutput>std::string evmc::hex (uint8_t b)<computeroutput>[inline]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Encode a byte to a hex string. </para>
</para>
<para>
Definition at line <link linkend="_hex_8hpp_source_1l00046">46</link> of file <link linkend="_hex_8hpp_source">hex.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00047"/>00047 {
<anchor xml:id="_namespaceevmc_1l00048"/>00048 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">constexpr</emphasis>&#32;<emphasis role="keyword">auto</emphasis>&#32;hex_chars&#32;=&#32;<emphasis role="stringliteral">&quot;0123456789abcdef&quot;</emphasis>;
<anchor xml:id="_namespaceevmc_1l00049"/>00049 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{hex_chars[b&#32;&gt;&gt;&#32;4],&#32;hex_chars[b&#32;&amp;&#32;0xf]};
<anchor xml:id="_namespaceevmc_1l00050"/>00050 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1ab7adb84a6060aa244b75958d73752696"/><section>
    <title>hex_category()</title>
<indexterm><primary>hex_category</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>hex_category</secondary></indexterm>
<para><computeroutput>const std::error_category &amp; evmc::hex_category ( )<computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Obtains a reference to the static error category object for hex errors. </para>
</para>
</section>
<anchor xml:id="_namespaceevmc_1afc53d0e831bda94fbf31a64d224c8d24"/><section>
    <title>is_zero()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>is_zero</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>is_zero</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::is_zero (const <link linkend="_structevmc_1_1address">address</link> &amp; a)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Checks if the given address is the zero address. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00251">251</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00252"/>00252 {
<anchor xml:id="_namespaceevmc_1l00253"/>00253 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;a&#32;==&#32;<link linkend="_structevmc_1_1address">address</link>{};
<anchor xml:id="_namespaceevmc_1l00254"/>00254 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1a2277f8eca7df22f45a4476d3fe6342fe"/><section>
    <title>is_zero()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>is_zero</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>is_zero</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::is_zero (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; a)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Checks if the given <link linkend="_structevmc_1_1bytes32">bytes32</link> object has all zero bytes. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00262">262</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00263"/>00263 {
<anchor xml:id="_namespaceevmc_1l00264"/>00264 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;a&#32;==&#32;<link linkend="_structevmc_1_1bytes32">bytes32</link>{};
<anchor xml:id="_namespaceevmc_1l00265"/>00265 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1a2170432bbbef84b33ce6dda30904068e"/><section>
    <title>load32be()</title>
<indexterm><primary>load32be</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>load32be</secondary></indexterm>
<para><computeroutput>constexpr uint32_t evmc::load32be (const uint8_t * data)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Loads 32 bits / 4 bytes of data from the given <computeroutput>data</computeroutput> array in big-endian order. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00137">137</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00138"/>00138 {
<anchor xml:id="_namespaceevmc_1l00139"/>00139 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(uint32_t{data[0]}&#32;&lt;&lt;&#32;24)&#32;|&#32;(uint32_t{data[1]}&#32;&lt;&lt;&#32;16)&#32;|&#32;(uint32_t{data[2]}&#32;&lt;&lt;&#32;8)&#32;|
<anchor xml:id="_namespaceevmc_1l00140"/>00140 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;uint32_t{data[3]};
<anchor xml:id="_namespaceevmc_1l00141"/>00141 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1ada9ae3e2b40c36dbea8b6fe8ab70375b"/><section>
    <title>load32le()</title>
<indexterm><primary>load32le</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>load32le</secondary></indexterm>
<para><computeroutput>constexpr uint32_t evmc::load32le (const uint8_t * data)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Loads 32 bits / 4 bytes of data from the given <computeroutput>data</computeroutput> array in little-endian order. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00144">144</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00145"/>00145 {
<anchor xml:id="_namespaceevmc_1l00146"/>00146 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;uint32_t{data[0]}&#32;|&#32;(uint32_t{data[1]}&#32;&lt;&lt;&#32;8)&#32;|&#32;(uint32_t{data[2]}&#32;&lt;&lt;&#32;16)&#32;|
<anchor xml:id="_namespaceevmc_1l00147"/>00147 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(uint32_t{data[3]}&#32;&lt;&lt;&#32;24);
<anchor xml:id="_namespaceevmc_1l00148"/>00148 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e"/><section>
    <title>load64be()</title>
<indexterm><primary>load64be</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>load64be</secondary></indexterm>
<para><computeroutput>constexpr uint64_t evmc::load64be (const uint8_t * data)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Loads 64 bits / 8 bytes of data from the given <computeroutput>data</computeroutput> array in big-endian order. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00121">121</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00122"/>00122 {
<anchor xml:id="_namespaceevmc_1l00123"/>00123 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(uint64_t{data[0]}&#32;&lt;&lt;&#32;56)&#32;|&#32;(uint64_t{data[1]}&#32;&lt;&lt;&#32;48)&#32;|&#32;(uint64_t{data[2]}&#32;&lt;&lt;&#32;40)&#32;|
<anchor xml:id="_namespaceevmc_1l00124"/>00124 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(uint64_t{data[3]}&#32;&lt;&lt;&#32;32)&#32;|&#32;(uint64_t{data[4]}&#32;&lt;&lt;&#32;24)&#32;|&#32;(uint64_t{data[5]}&#32;&lt;&lt;&#32;16)&#32;|
<anchor xml:id="_namespaceevmc_1l00125"/>00125 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(uint64_t{data[6]}&#32;&lt;&lt;&#32;8)&#32;|&#32;uint64_t{data[7]};
<anchor xml:id="_namespaceevmc_1l00126"/>00126 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df"/><section>
    <title>load64le()</title>
<indexterm><primary>load64le</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>load64le</secondary></indexterm>
<para><computeroutput>constexpr uint64_t evmc::load64le (const uint8_t * data)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Loads 64 bits / 8 bytes of data from the given <computeroutput>data</computeroutput> array in little-endian order. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00129">129</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00130"/>00130 {
<anchor xml:id="_namespaceevmc_1l00131"/>00131 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;uint64_t{data[0]}&#32;|&#32;(uint64_t{data[1]}&#32;&lt;&lt;&#32;8)&#32;|&#32;(uint64_t{data[2]}&#32;&lt;&lt;&#32;16)&#32;|
<anchor xml:id="_namespaceevmc_1l00132"/>00132 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(uint64_t{data[3]}&#32;&lt;&lt;&#32;24)&#32;|&#32;(uint64_t{data[4]}&#32;&lt;&lt;&#32;32)&#32;|&#32;(uint64_t{data[5]}&#32;&lt;&lt;&#32;40)&#32;|
<anchor xml:id="_namespaceevmc_1l00133"/>00133 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(uint64_t{data[6]}&#32;&lt;&lt;&#32;48)&#32;|&#32;(uint64_t{data[7]}&#32;&lt;&lt;&#32;56);
<anchor xml:id="_namespaceevmc_1l00134"/>00134 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1aaf35d1ee5ad04f36c4287e9bafb4bd48"/><section>
    <title>make_error_code()</title>
<indexterm><primary>make_error_code</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>make_error_code</secondary></indexterm>
<para><computeroutput>std::error_code evmc::make_error_code (<link linkend="_namespaceevmc_1a37d7a743959a67434404404b257b2fd4">hex_errc</link> errc)<computeroutput>[inline]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Creates error_code object out of a hex error code value. </para>
</para>
<para>
Definition at line <link linkend="_hex_8hpp_source_1l00034">34</link> of file <link linkend="_hex_8hpp_source">hex.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00035"/>00035 {
<anchor xml:id="_namespaceevmc_1l00036"/>00036 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keywordtype">int</emphasis><emphasis role="keyword">&gt;</emphasis>(errc),&#32;<link linkend="_namespaceevmc_1ab7adb84a6060aa244b75958d73752696">hex_category</link>()};
<anchor xml:id="_namespaceevmc_1l00037"/>00037 }
</programlisting>Here is the call graph for this function:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="namespaceevmc_aaf35d1ee5ad04f36c4287e9bafb4bd48_cgraph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
</section>
<anchor xml:id="_namespaceevmc_1acef96efd7f9847cc089834dff73054bd"/><section>
    <title>operator!=()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>operator!=</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator!=</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator!= (const <link linkend="_structevmc_1_1address">address</link> &amp; a, const <link linkend="_structevmc_1_1address">address</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;not equal to&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00172">172</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00173"/>00173 {
<anchor xml:id="_namespaceevmc_1l00174"/>00174 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;!(a&#32;==&#32;b);
<anchor xml:id="_namespaceevmc_1l00175"/>00175 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1a5917d256b4c67912a47d3a54f849f751"/><section>
    <title>operator!=()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>operator!=</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator!=</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator!= (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;not equal to&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00215">215</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00216"/>00216 {
<anchor xml:id="_namespaceevmc_1l00217"/>00217 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;!(a&#32;==&#32;b);
<anchor xml:id="_namespaceevmc_1l00218"/>00218 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1a0a5557fb3dc3c04da6ef466ec3bb4d4c"/><section>
    <title>operator&lt;()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>operator&lt;</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator&lt;</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator&lt; (const <link linkend="_structevmc_1_1address">address</link> &amp; a, const <link linkend="_structevmc_1_1address">address</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;less than&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00178">178</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00179"/>00179 {
<anchor xml:id="_namespaceevmc_1l00180"/>00180 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[0])&#32;&lt;&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[0])&#32;||
<anchor xml:id="_namespaceevmc_1l00181"/>00181 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[0])&#32;==&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[0])&#32;&amp;&amp;
<anchor xml:id="_namespaceevmc_1l00182"/>00182 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[8])&#32;&lt;&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[8])&#32;||
<anchor xml:id="_namespaceevmc_1l00183"/>00183 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[8])&#32;==&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[8])&#32;&amp;&amp;
<anchor xml:id="_namespaceevmc_1l00184"/>00184 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespaceevmc_1a2170432bbbef84b33ce6dda30904068e">load32be</link>(&amp;a.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[16])&#32;&lt;&#32;<link linkend="_namespaceevmc_1a2170432bbbef84b33ce6dda30904068e">load32be</link>(&amp;b.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[16]))));
<anchor xml:id="_namespaceevmc_1l00185"/>00185 }
</programlisting>Here is the call graph for this function:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="namespaceevmc_a0a5557fb3dc3c04da6ef466ec3bb4d4c_cgraph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
</section>
<anchor xml:id="_namespaceevmc_1a4a0c61db81ebf11230c1506f7fc9e003"/><section>
    <title>operator&lt;()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>operator&lt;</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator&lt;</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator&lt; (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;less than&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00221">221</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00222"/>00222 {
<anchor xml:id="_namespaceevmc_1l00223"/>00223 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[0])&#32;&lt;&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[0])&#32;||
<anchor xml:id="_namespaceevmc_1l00224"/>00224 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[0])&#32;==&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[0])&#32;&amp;&amp;
<anchor xml:id="_namespaceevmc_1l00225"/>00225 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[8])&#32;&lt;&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[8])&#32;||
<anchor xml:id="_namespaceevmc_1l00226"/>00226 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[8])&#32;==&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[8])&#32;&amp;&amp;
<anchor xml:id="_namespaceevmc_1l00227"/>00227 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[16])&#32;&lt;&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[16])&#32;||
<anchor xml:id="_namespaceevmc_1l00228"/>00228 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[16])&#32;==&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[16])&#32;&amp;&amp;
<anchor xml:id="_namespaceevmc_1l00229"/>00229 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[24])&#32;&lt;&#32;<link linkend="_namespaceevmc_1a1a253fea559bb97f713b91903ffc860e">load64be</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[24]))))));
<anchor xml:id="_namespaceevmc_1l00230"/>00230 }
</programlisting>Here is the call graph for this function:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="namespaceevmc_a4a0c61db81ebf11230c1506f7fc9e003_cgraph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
</section>
<anchor xml:id="_namespaceevmc_1ac0dc436fe57925210dcd0481a79e9784"/><section>
    <title>operator&lt;=()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>operator&lt;=</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator&lt;=</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator&lt;= (const <link linkend="_structevmc_1_1address">address</link> &amp; a, const <link linkend="_structevmc_1_1address">address</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;less than or equal to&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00194">194</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00195"/>00195 {
<anchor xml:id="_namespaceevmc_1l00196"/>00196 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;!(b&#32;&lt;&#32;a);
<anchor xml:id="_namespaceevmc_1l00197"/>00197 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1a8580df251c76ac9b0a1561cbfda93274"/><section>
    <title>operator&lt;=()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>operator&lt;=</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator&lt;=</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator&lt;= (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;less than or equal to&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00239">239</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00240"/>00240 {
<anchor xml:id="_namespaceevmc_1l00241"/>00241 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;!(b&#32;&lt;&#32;a);
<anchor xml:id="_namespaceevmc_1l00242"/>00242 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1a3f6b3b885e1053cebe81913583212e70"/><section>
    <title>operator==()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>operator==</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator==</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator== (const <link linkend="_structevmc_1_1address">address</link> &amp; a, const <link linkend="_structevmc_1_1address">address</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;equal to&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00164">164</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00165"/>00165 {
<anchor xml:id="_namespaceevmc_1l00166"/>00166 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;a.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[0])&#32;==&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;b.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[0])&#32;&amp;&amp;
<anchor xml:id="_namespaceevmc_1l00167"/>00167 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;a.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[8])&#32;==&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;b.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[8])&#32;&amp;&amp;
<anchor xml:id="_namespaceevmc_1l00168"/>00168 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespaceevmc_1ada9ae3e2b40c36dbea8b6fe8ab70375b">load32le</link>(&amp;a.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[16])&#32;==&#32;<link linkend="_namespaceevmc_1ada9ae3e2b40c36dbea8b6fe8ab70375b">load32le</link>(&amp;b.<link linkend="_structevmc__address_1ab43a790ce0efb282b7ed7eafff8ed614">bytes</link>[16]);
<anchor xml:id="_namespaceevmc_1l00169"/>00169 }
</programlisting>Here is the call graph for this function:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="namespaceevmc_a3f6b3b885e1053cebe81913583212e70_cgraph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
</section>
<anchor xml:id="_namespaceevmc_1a338b7c7a6dd5c12c0e37e5e8ef729100"/><section>
    <title>operator==()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>operator==</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator==</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator== (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;equal to&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00206">206</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00207"/>00207 {
<anchor xml:id="_namespaceevmc_1l00208"/>00208 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[0])&#32;==&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[0])&#32;&amp;&amp;
<anchor xml:id="_namespaceevmc_1l00209"/>00209 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[8])&#32;==&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[8])&#32;&amp;&amp;
<anchor xml:id="_namespaceevmc_1l00210"/>00210 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[16])&#32;==&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[16])&#32;&amp;&amp;
<anchor xml:id="_namespaceevmc_1l00211"/>00211 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;a.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[24])&#32;==&#32;<link linkend="_namespaceevmc_1acd1275224a4eb5f6a672507d144065df">load64le</link>(&amp;b.<link linkend="_structevmc__bytes32_1a695eaf3c428daee54ce15c8252edc133">bytes</link>[24]);
<anchor xml:id="_namespaceevmc_1l00212"/>00212 }
</programlisting>Here is the call graph for this function:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="namespaceevmc_a338b7c7a6dd5c12c0e37e5e8ef729100_cgraph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
</section>
<anchor xml:id="_namespaceevmc_1a44333e715985f766f2493b20ed665fbd"/><section>
    <title>operator&gt;()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>operator&gt;</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator&gt;</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator&gt; (const <link linkend="_structevmc_1_1address">address</link> &amp; a, const <link linkend="_structevmc_1_1address">address</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;greater than&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00188">188</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00189"/>00189 {
<anchor xml:id="_namespaceevmc_1l00190"/>00190 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;b&#32;&lt;&#32;a;
<anchor xml:id="_namespaceevmc_1l00191"/>00191 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1a04835f698b6a2a5d2fbc3f8234518aed"/><section>
    <title>operator&gt;()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>operator&gt;</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator&gt;</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator&gt; (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;greater than&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00233">233</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00234"/>00234 {
<anchor xml:id="_namespaceevmc_1l00235"/>00235 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;b&#32;&lt;&#32;a;
<anchor xml:id="_namespaceevmc_1l00236"/>00236 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1aa1739e6e990dbd1fd3d30b249b1d0d58"/><section>
    <title>operator&gt;=()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>operator&gt;=</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator&gt;=</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator&gt;= (const <link linkend="_structevmc_1_1address">address</link> &amp; a, const <link linkend="_structevmc_1_1address">address</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;greater than or equal to&quot; comparison operator for the <link linkend="_structevmc_1_1address">evmc::address</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00200">200</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00201"/>00201 {
<anchor xml:id="_namespaceevmc_1l00202"/>00202 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;!(a&#32;&lt;&#32;b);
<anchor xml:id="_namespaceevmc_1l00203"/>00203 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1ad830a8c519d4baf674a220480efc8ad3"/><section>
    <title>operator&gt;=()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>operator&gt;=</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>operator&gt;=</secondary></indexterm>
<para><computeroutput>constexpr bool evmc::operator&gt;= (const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; a, const <link linkend="_structevmc_1_1bytes32">bytes32</link> &amp; b)<computeroutput>[inline]</computeroutput>, <computeroutput>[constexpr]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The &quot;greater than or equal to&quot; comparison operator for the <link linkend="_structevmc_1_1bytes32">evmc::bytes32</link> type. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00245">245</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00246"/>00246 {
<anchor xml:id="_namespaceevmc_1l00247"/>00247 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;!(a&#32;&lt;&#32;b);
<anchor xml:id="_namespaceevmc_1l00248"/>00248 }
</programlisting></section>
<anchor xml:id="_namespaceevmc_1a773edff68f6e013b3c809bb4c6ea33d3"/><section>
    <title>to_string()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>to_string</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>to_string</secondary></indexterm>
<para><computeroutput>const char * evmc::to_string (<link linkend="_group__EVMC_1gae5759b1590071966ccf6a505b52a0ef7">evmc_revision</link> rev)<computeroutput>[inline]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Returns the name of the <link linkend="_group__EVMC_1gae5759b1590071966ccf6a505b52a0ef7">evmc_revision</link>. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00352">352</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00353"/>00353 {
<anchor xml:id="_namespaceevmc_1l00354"/>00354 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_group__helpers_1gad04bac3144296562478b0447bf3991ff">evmc_revision_to_string</link>(rev);
<anchor xml:id="_namespaceevmc_1l00355"/>00355 }
</programlisting>Here is the call graph for this function:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="namespaceevmc_a773edff68f6e013b3c809bb4c6ea33d3_cgraph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
</section>
<anchor xml:id="_namespaceevmc_1a44c9aad0ac3f324d817e18720a1e37de"/><section>
    <title>to_string()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>to_string</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>to_string</secondary></indexterm>
<para><computeroutput>const char * evmc::to_string (<link linkend="_group__EVMC_1ga4c0be97f333c050ff45321fcaa34d920">evmc_status_code</link> status_code)<computeroutput>[inline]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Returns text representation of the <link linkend="_group__EVMC_1ga4c0be97f333c050ff45321fcaa34d920">evmc_status_code</link>. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00346">346</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
<programlisting linenumbering="unnumbered"><anchor xml:id="_namespaceevmc_1l00347"/>00347 {
<anchor xml:id="_namespaceevmc_1l00348"/>00348 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_group__helpers_1gad9e0e4b4cf8323982572dc54d36f0b40">evmc_status_code_to_string</link>(status_code);
<anchor xml:id="_namespaceevmc_1l00349"/>00349 }
</programlisting>Here is the call graph for this function:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="namespaceevmc_a44c9aad0ac3f324d817e18720a1e37de_cgraph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
</section>
<anchor xml:id="_namespaceevmc_1aad6a175f9f53ee5700cb0c233efba79b"/><section>
    <title>validate_hex()</title>
<indexterm><primary>validate_hex</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>validate_hex</secondary></indexterm>
<para><computeroutput>std::error_code evmc::validate_hex (std::string_view hex)<computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Validates hex encoded string. </para>
</para>
</section>
</section>
<section>
<title>Variable Documentation</title>
<anchor xml:id="_namespaceevmc_1a9843b267dc279832b0ff9578b7dacdb7"/><section>
    <title>make_result</title>
<indexterm><primary>make_result</primary><secondary>evmc</secondary></indexterm>
<indexterm><primary>evmc</primary><secondary>make_result</secondary></indexterm>
<para><computeroutput>constexpr auto evmc::make_result = <link linkend="_group__helpers_1ga1eb1facc9b5ddacda368ffdeb89d1a20">evmc_make_result</link><computeroutput>[constexpr]</computeroutput></computeroutput></para><para>

<para>Alias for <link linkend="_group__helpers_1ga1eb1facc9b5ddacda368ffdeb89d1a20">evmc_make_result()</link>. </para>
</para>
<para>
Definition at line <link linkend="_evmc_8hpp_source_1l00359">359</link> of file <link linkend="_evmc_8hpp_source">evmc.hpp</link>.</para>
</section>
</section>
</section>
