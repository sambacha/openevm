---
title: "R Notebook: initial exploration for Gas Cost Estimator"
output: html_notebook
---

```{r include=FALSE, fig.width=20}
library(sqldf)
```

<!---
This style tag is for `<div class="superbigimage">` to have a horizontal scrollbar in the HTML output
use:
<div class="superbigimage">
plot
</div>
source: https://stackoverflow.com/questions/52448104/how-to-add-horizontal-scroll-bar-for-a-ggplot-plot-in-rmarkdown-html
-->
<style>
  .superbigimage{
      overflow-x:scroll;
      white-space: nowrap;
  }
  .superbigimage img{
     max-width: none;
  }
</style>

## Data preparations

Read in the `programs.csv` as generated by `src/program_generator.py` with `--fullCSV` flag on:
```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")
programs_evm = read.csv("../../local/programs.csv")
programs_ewasm = read.csv("../../local/programs_ewasm.csv")
```
Unfortunately `JUMP` and `JUMPI` are currently broken in `geth` (they require a `JUMPDEST`).
Because they work in `evmone` (it prepends `JUMPDEST`) forcefully, we should drop them from the analisys. **TODO** fix this somehow.
Also `RETURNDATACOPY` program generation is broken in general (`return data out of bounds`).
`nop` for Ewasm isn't executed at all in `openethereum`, drop it:
```{r fig.width=20}
programs_evm = programs_evm[which(programs_evm$opcode_measured != "JUMP"), ]
programs_evm = programs_evm[which(programs_evm$opcode_measured != "JUMPI"), ]
programs_evm = programs_evm[which(programs_evm$opcode_measured != "RETURNDATACOPY"), ]
programs_ewasm = programs_ewasm[which(programs_ewasm$opcode_measured != "nop"), ]

# necessary to get rid of the factor levels which we just filtered out
programs_evm = droplevels(programs_evm)
programs_ewasm = droplevels(programs_ewasm)

programs = rbind(programs_evm, programs_ewasm)
head(programs)
```

Modify `programs.csv` to adjust for the fact, that `evmone` prepends a `JUMPDEST` instruction at the vary beginning of each bytecode:
(**TODO** track and adjust for the programs instructions more elegantly)

```{r fig.width=20}
programs$measured_op_position_evmone = programs$measured_op_position + 1
head(programs)
```

Modify `programs_ewasm.csv` to adjust for the fact, that there are many instructions executed before ours.

```{r fig.width=20}
programs$measured_op_position_ewasm = programs$measured_op_position + 11
head(programs)
```

Read in the `result_geth.csv` and `result_evmone.csv` as generated by `src/measurements.py`

```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")
result_geth = read.csv("../../local/result_geth.csv")
result_evmone = read.csv("../../local/result_evmone.csv")
result_openethereum = read.csv("../../local/result_openethereum.csv")
result_ewasm = read.csv("../../local/result_ewasm.csv")
result_geth$env = "geth"
result_evmone$env = "evmone"
result_openethereum$env = "openethereum"
result_ewasm$env = "ewasm"
results = rbind(result_geth, result_evmone, result_openethereum, result_ewasm)
head(results)
```

Combine the two tables to see only times of the measured opcodes.

```{r fig.width=20}
measurements = sqldf("SELECT opcode_measured, sample_id, run_id, measure_all_time_ns, env
                     FROM results
                     INNER JOIN
                       programs ON(results.program_id = programs.program_id)
                     WHERE
                       (results.instruction_id = programs.measured_op_position AND results.env = 'geth') OR
                       (results.instruction_id = programs.measured_op_position_evmone AND results.env = 'evmone') OR
                       (results.instruction_id = programs.measured_op_position AND results.env = 'openethereum') OR
                       (results.instruction_id = programs.measured_op_position_ewasm AND results.env = 'ewasm')
                     ")

head(measurements)
```

**TODO** some result CSVs don't look good, some measurements are missing, investigate (mainly impacts the excluded OPCODEs):
```{r include=FALSE}
sqldf("SELECT program_id, count(*) FROM result_openethereum GROUP BY program_id")
sqldf("SELECT program_id, count(*) FROM result_evmone GROUP BY program_id")
```

Let's also adjust for the rough estimate of the overhead of the timer.
We're subtracting these estimates from all measurements, for more granularity on the fastest instructions.

Our "ball-park" estimates of minimum clock measurement overhead:

- blue - `geth` - `17ns` ([minimum for `runtimeNano`](https://htmlpreview.github.io/?https://github.com/imapp-pl/gas-cost-estimator/blob/master/src/analysis/exploration_timers.nb.html))
  - (earlier try: `30ns` median for `runtimeNano` from a different measurement)
- pink - `evmone` - `16ns` (minimum, see link as above)
  - (earlier try: `9ns` wild guess, half of smallest measurement)
  - (2nd earlier try: `29.32ns` as below with earlier set of result data)
  - (3rd earlier try: `28.32ns` (2nd wild guess, this makes our results calibrate with ones inferred from [`chfast`'s benchmarks](https://notes.ethereum.org/@chfast/benchmarking-evm-instructions). We try here to have `NOT` opcode match the time from there, which is `881us/256/2048 = 1.68ns`. Our median measurement without adjustment was `30`, so `30 - 1.68 = 28.32ns`)
- green - `openethereum` - `17ns` (minimum, see link as above)
  - (earlier try: `30ns` just the same as `geth` above)
- yellow - `ewasm` - same as `openethereum`

```{r fig.width=20}
rough_estimate_time_overhead_geth = 17
rough_estimate_time_overhead_evmone = 16
rough_estimate_time_overhead_openethereum = 17

measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]
measurements_ewasm = measurements[which(measurements$env=="ewasm"), ]

measurements_geth$measure_all_time_ns_raw = measurements_geth$measure_all_time_ns
measurements_evmone$measure_all_time_ns_raw = measurements_evmone$measure_all_time_ns
measurements_openethereum$measure_all_time_ns_raw = measurements_openethereum$measure_all_time_ns
measurements_ewasm$measure_all_time_ns_raw = measurements_ewasm$measure_all_time_ns

measurements_geth$measure_all_time_ns = measurements_geth$measure_all_time_ns_raw - rough_estimate_time_overhead_geth
measurements_evmone$measure_all_time_ns = measurements_evmone$measure_all_time_ns_raw - rough_estimate_time_overhead_evmone
measurements_openethereum$measure_all_time_ns = measurements_openethereum$measure_all_time_ns_raw - rough_estimate_time_overhead_openethereum
measurements_ewasm$measure_all_time_ns = measurements_ewasm$measure_all_time_ns_raw - rough_estimate_time_overhead_openethereum
measurements = rbind(measurements_geth, measurements_evmone, measurements_openethereum, measurements_ewasm)

check_columns = c("env", "measure_all_time_ns", "measure_all_time_ns_raw")
head(measurements)
```

```{r include=FALSE}
# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum, measurements_ewasm)
```

A necessary touch to prepare the data - we want the opcodes factor to be ordered by the natural opcode order.
For now we'll use the original order from `programs.csv`, which coincides, but this must be improved (**TODO**).
We'll also have `geth` first, and proceed in the order of completing the instrumentations.
```{r fig.width=20}
measurements$env = factor(measurements$env, levels=c("geth", "evmone", "openethereum", "ewasm"))
measurements$env_evm = factor(measurements$env, levels=c("geth", "evmone", "openethereum"))

measurements$opcode_measured_evm = factor(measurements$opcode_measured, levels=programs_evm$opcode_measured)
measurements$opcode_measured_ewasm = factor(measurements$opcode_measured, levels=programs_ewasm$opcode_measured)
measurements$opcode_measured = factor(measurements$opcode_measured, levels=programs$opcode_measured)
```

## Overview

Quick overview of times; everything and by env:

```{r fig.width=20}
summary(measurements$measure_all_time_ns)

tapply(measurements$measure_all_time_ns, measurements$env, summary)
```

Quick overview of measurements per opcode:
```{r fig.width=20}
measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]
measurements_ewasm = measurements[which(measurements$env=="ewasm"), ]

print("geth")
tapply(measurements_geth$measure_all_time_ns, measurements_geth$opcode_measured_evm, summary)
print("evmone")
tapply(measurements_evmone$measure_all_time_ns, measurements_evmone$opcode_measured_evm, summary)
print("openethereum")
tapply(measurements_openethereum$measure_all_time_ns, measurements_openethereum$opcode_measured_evm, summary)
print("ewasm")
tapply(measurements_ewasm$measure_all_time_ns, measurements_ewasm$opcode_measured_ewasm, summary)
```

```{r include=FALSE}
# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum, measurements_ewasm)
```
`PUSH1`-`PUSH8` OPCODEs for `evmone` are extremely cheap, they're additionally optimized there.

(Pushes of more than 8 bytes look more expensive, what is special about pushes under 8 bytes for `evmone`?

Mystery solved in `evmone/lib/evmone/opcodes_helpers.h`:
```c
#define ANY_SMALL_PUSH \
    OP_PUSH1:          \
    case OP_PUSH2:     \
    case OP_PUSH3:     \
    case OP_PUSH4:     \
    case OP_PUSH5:     \
    case OP_PUSH6:     \
    case OP_PUSH7:     \
    case OP_PUSH8
```
- they get special treatment)

## Implementation-relative measurements

We want to introduce a notion of implementation-relative measurements, where we express them in the multiples of "mean `COINBASE` duration", as opposed to ns.
Let's call the selected operation **"pivot OPCODE"**.

We're using `COINBASE` as the pivot OPCODE because it is (**TODO** verify all points, pick a better one):

- relatively slow, so timer measurement overhead and precision have little impact
- seems to be free of surprises or influences of suboptimal implementation
- no outliers
- seem to be a rather typical opcode in terms of timing in both implementations (it allows similar calibration to that using an overall mean)
- `COINBASE` seems a rather peculiar choice for a pivot OPCODE, but `¯\_(ツ)_/¯`
- (earlier pick was `POP`, but it is very cheap, close to timer measurement and precision)
- (second pick was `EXP(0, 0)`, but it had a bad outlier, we can revisit after the `evmone` outliers are sorted, **TODO**)
- (third and fourth picks were `MULMOD(0, 0, 0)` and `GT(0, 0)`, but they belong to two groups which time very differently in `geth`/`evmone` - `geth` seems faster in arithmetic and slower in logical and comparison operators (**TODO** explore this more)

For Ewasm we're using `i32.const 32` which seems to give the most reliable result.

```{r fig.width=20}
measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]
measurements_ewasm = measurements[which(measurements$env=="ewasm"), ]

pivot_opcode = "COINBASE"
pivot_opcode_ewasm = "i32.const 32"
means = c(
  mean(measurements_geth[which(measurements_geth$opcode_measured==pivot_opcode), "measure_all_time_ns"]),
  mean(measurements_evmone[which(measurements_geth$opcode_measured==pivot_opcode), "measure_all_time_ns"]),
  mean(measurements_openethereum[which(measurements_openethereum$opcode_measured==pivot_opcode), "measure_all_time_ns"]),
  mean(measurements_ewasm[which(measurements_ewasm$opcode_measured==pivot_opcode_ewasm), "measure_all_time_ns"])
)

pivot_statistics = data.frame(
  mean_measure_all_time_ns=means, row.names=c("geth", "evmone", "openethereum", "ewasm")
)
head(pivot_statistics)
measurements_geth$measure_all_time_ns_rel = measurements_geth$measure_all_time_ns / pivot_statistics["geth", "mean_measure_all_time_ns"]
measurements_evmone$measure_all_time_ns_rel = measurements_evmone$measure_all_time_ns / pivot_statistics["evmone", "mean_measure_all_time_ns"]
measurements_openethereum$measure_all_time_ns_rel = measurements_openethereum$measure_all_time_ns / pivot_statistics["openethereum", "mean_measure_all_time_ns"]
measurements_ewasm$measure_all_time_ns_rel = measurements_ewasm$measure_all_time_ns / pivot_statistics["ewasm", "mean_measure_all_time_ns"]
measurements = rbind(measurements_geth, measurements_evmone, measurements_openethereum, measurements_ewasm)

check_columns = c("env", "measure_all_time_ns", "measure_all_time_ns_rel")
head(measurements[which(measurements$opcode_measured==pivot_opcode & measurements$env=="geth"), check_columns])
head(measurements[which(measurements$opcode_measured==pivot_opcode & measurements$env=="evmone"), check_columns])
head(measurements[which(measurements$opcode_measured==pivot_opcode & measurements$env=="openethereum"), check_columns])
head(measurements[which(measurements$opcode_measured==pivot_opcode_ewasm & measurements$env=="ewasm"), check_columns])
```

```{r include=FALSE}
# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum, measurements_ewasm)
```

## Measurements exploration

Let's compare the implementations in an absolute fashion (note we're not showing outliers for `evmone` because they're very large - **TODO** investigate what happened. UPDATE: `geth` has massive outliers too, after adding all the opcodes):

```{r include=FALSE, fig.width=20}
measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]

geth_color = rgb(0.1,0.1,0.7,0.5)
evmone_color = rgb(0.8,0.1,0.3,0.6)
openethereum_color = rgb(0.1,0.7,0.1,0.5)
ewasm_color = rgb(0.7,0.7,0.1,0.5)
```

<div class="superbigimage">
```{r fig.width=30, fig.height=10}
par(mfrow=c(3,1), mar = c(6,4,1,2) + 0.1)
boxplot(measure_all_time_ns ~ opcode_measured_evm, data=measurements_geth, col=geth_color, outline=FALSE, las=2)
boxplot(measure_all_time_ns ~ opcode_measured_evm, data=measurements_evmone, col=evmone_color, las=2, outline=FALSE, xaxt="n")
boxplot(measure_all_time_ns ~ opcode_measured_evm, data=measurements_openethereum, col=openethereum_color, las=2, outline=FALSE, xaxt="n")
```

</div>
```{r include=FALSE, fig.width=20}
# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum)
```

```{r fig.width=20}
measurements_ewasm = measurements[which(measurements$env=="ewasm"), ]

boxplot(measure_all_time_ns ~ opcode_measured_ewasm, data=measurements_ewasm, col=ewasm_color, outline=FALSE, las=2)
```

```{r include=FALSE}
# cleanup
rm(measurements_ewasm)
```

To compare the opcodes on a single boxplot side by side, still absolute times:


```{r include=FALSE, fig.width=20}
par(mar = c(8,4,1,2) + 0.1)
env_colors = c(geth_color, evmone_color, openethereum_color, ewasm_color)
env_colors_evm = c(geth_color, evmone_color, openethereum_color)

mix_colors_evm = rep(env_colors_evm, times=length(levels(programs_evm$opcode_measured)))
mix_colors_ewasm = rep(ewasm_color, times=length(levels(programs_ewasm$opcode_measured)))
mix_colors = c(mix_colors_evm, mix_colors_ewasm)
```

<div class="superbigimage">
```{r fig.width=35, fig.height=10}

# col is recycled so we need to match exactly the sequence we want here - first evm, then ewasm
# drop makes empty boxplots not show up, i.e. `PUSH1` for `ewasm`
boxplot(measure_all_time_ns ~ env:opcode_measured, data=measurements, las=2, col=mix_colors, outline=FALSE, cex.axis=0.5, drop=TRUE)
```
</div>

```{r include=FALSE, fig.width=20}
# TODO: own labels, still doesn't look good, fix this
# library(plyr)
# boxplot(measure_all_time_ns ~ env:opcode_measured, data=measurements, las=2, col=env_colors, outline=FALSE, xaxt="n")
# axis(side = 1, labels = FALSE)
# labels = expand.grid(levels(measurements$env), levels(measurements$opcode_measured))
# labels = mdply(labels, "paste", sep=".")
# text(x = 1:nrow(measurements),
#      y = par("usr")[3] - 50.45,
#      labels = labels$V1,
#      xpd = NA,
#      ## Rotate the labels by 35 degrees.
#      srt = 45,
#      cex = 0.5)
```

---

Now let's compare using the relative times, measured in multiples of the duration of the pivot OPCODE (see above):

<div class="superbigimage">
```{r fig.width=35, fig.height=10}
par(mar = c(8,4,1,2) + 0.1)
boxplot(measure_all_time_ns_rel ~ env:opcode_measured, data=measurements, las=2, col=mix_colors, outline=FALSE, cex.axis=0.5, drop=TRUE)
legend(-10, 6.3, c("Geth", "Evmone", "OpenEthereum", "OpenEthereum Ewasm"), fill=env_colors, cex=1.3)
abline(h=1, col="red", lty=3)
```
</div>

```{r include=FALSE}
# export the plot to SVG for embedding
svg(filename="implementation_relative_all_opcodes.svg", width=35, height=10)
par(mar = c(8,4,1,2) + 0.1)
boxplot(measure_all_time_ns_rel ~ env:opcode_measured, data=measurements, las=2, col=mix_colors, outline=FALSE, cex.axis=0.5, drop=TRUE)
legend(-10, 6.3, c("Geth", "Evmone", "OpenEthereum", "OpenEthereum Ewasm"), fill=env_colors, cex=1.3)
abline(h=1, col="red", lty=3)
dev.off()
```

```{r fig.width=20}
measurements_ewasm = measurements[which(measurements$env=="ewasm"), ]

boxplot(measure_all_time_ns_rel ~ opcode_measured_ewasm, data=measurements_ewasm, las=2, col=ewasm_color, outline=FALSE, cex.axis=0.5)
abline(h=1, col="red", lty=3)
```


```{r include=FALSE}
# cleanup
rm(measurements_ewasm)
```

The red, dotted line is 1, which coincides with respective mean of pivot OPCODE (see above) measurement for the different environments.

---

**TODO** check these again, some look weird.

```{r fig.width=20}
measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]
measurements_ewasm = measurements[which(measurements$env=="ewasm"), ]

n_programs = nrow(programs)
n_plot_cols = 17
n_plot_rows = n_programs %/% n_plot_cols + 1
```

<div class="superbigimage">
```{r fig.width=40, fig.height=10}
par(mfrow=c(n_plot_rows, n_plot_cols))
for (opcode in programs_evm$opcode_measured)
{
  frequencies = sort(table(measurements_geth[which(measurements_geth$opcode_measured_evm==opcode), "measure_all_time_ns_raw"]), decreasing=TRUE)
  n = min(10, nrow(frequencies))
  plot(frequencies[1:n], yaxt="n", ylab="", xlab=c(opcode, " geth"), col=geth_color)
}
```
</div>

<div class="superbigimage">
```{r fig.width=40, fig.height=10}
par(mfrow=c(n_plot_rows, n_plot_cols))
for (opcode in programs_evm$opcode_measured)
{
  frequencies = sort(table(measurements_evmone[which(measurements_evmone$opcode_measured_evm==opcode), "measure_all_time_ns_raw"]), decreasing=TRUE)
  n = min(10, nrow(frequencies))
  if (length(frequencies) == 0) next
  plot(frequencies[1:n], yaxt="n", ylab="", xlab=c(opcode, " evmone"), col=evmone_color)
}
```
</div>

<div class="superbigimage">
```{r fig.width=40, fig.height=10}
par(mfrow=c(n_plot_rows, n_plot_cols))
for (opcode in programs_evm$opcode_measured)
{
  frequencies = sort(table(measurements_openethereum[which(measurements_openethereum$opcode_measured_evm==opcode), "measure_all_time_ns_raw"]), decreasing=TRUE)
  n = min(10, nrow(frequencies))
  if (length(frequencies) == 0) next
  plot(frequencies[1:n], yaxt="n", ylab="", xlab=c(opcode, " evmone"), col=openethereum_color)
}
```
</div>


<div class="superbigimage">
```{r fig.width=20}
n_programs = nrow(programs_ewasm)
n_plot_cols = 7
n_plot_rows = n_programs %/% n_plot_cols + 1
par(mfrow=c(n_plot_rows, n_plot_cols))
for (opcode in programs_ewasm$opcode_measured)
{
  frequencies = sort(table(measurements_ewasm[which(measurements_ewasm$opcode_measured_ewasm==opcode), "measure_all_time_ns_raw"]), decreasing=TRUE)
  n = min(10, nrow(frequencies))
  if (length(frequencies) == 0) next
  plot(frequencies[1:n], yaxt="n", ylab="", xlab=c(opcode, " openethereum_ewasm"), col=ewasm_color)
}
```
</div>

```{r include=FALSE, fig.width=20}
# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum, measurements_ewasm)
```

---

## Exploration of other warm-up

Quick check that `sample_id` shouldn't impact measurements:

```{r fig.width=20}
boxplot(measure_all_time_ns ~ sample_id:env, data=measurements, las=2)
boxplot(measure_all_time_ns ~ sample_id:env, data=measurements, outline=FALSE, las=2)
```

But `run_id` does impact measurements: first several runs have a decreasing trend. **TODO** needs investigation how/if to alleviate 
(**TODO** we probably should undo the warm-up for `geth`, others don't do this and it shows here. If at all, discard warm-up on analysis stage):

```{r fig.width=20}
measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]
measurements_ewasm = measurements[which(measurements$env=="ewasm"), ]

par(mfrow=c(2,2))
boxplot(measure_all_time_ns ~ run_id, data=measurements_geth, las=2, outline=FALSE, xlab="geth")
boxplot(measure_all_time_ns ~ run_id, data=measurements_evmone, las=2, outline=FALSE, xlab="evmone")
boxplot(measure_all_time_ns ~ run_id, data=measurements_openethereum, las=2, outline=FALSE, xlab="openethereum")
boxplot(measure_all_time_ns ~ run_id, data=measurements_ewasm, las=2, outline=FALSE, xlab="ewasm")
```

```{r include=FALSE}
# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum, measurements_ewasm)
```
